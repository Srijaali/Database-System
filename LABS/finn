SET SERVEROUTPUT ON;

BEGIN
    DBMS_OUTPUT.PUT_LINE('happyyyy');
END;
/

DECLARE
name varchar(20);
age number;
BEGIN
name := 'rija';
age := 20;
DBMS_OUTPUT.PUT_LINE(name);
DBMS_OUTPUT.PUT_LINE(age);
END;
/

DECLARE
a integer := 2;
b integer := 3;
c integer := 4;
f real;
BEGIN
c := a+b;
f := 70.0/3.0;

dbms_output.put_line('c is: ' || c);
dbms_output.put_line('f is: ' || f);
END;

DECLARE 
num1 number := 20;
num2 number := 30;
BEGIN
dbms_output.put_line(num1);
dbms_output.put_line(num2);
    DECLARE
    num1 number := 50;
    num2 number := 80;
    BEGIN
    dbms_output.put_line(num1);
    dbms_output.put_line(num2);
    END;
END;
/
select*from hr.employees;

DECLARE
e_id hr.employees.employee_id%TYPE;
e_fn hr.employees.first_name%TYPE;
e_ln hr.employees.last_name%TYPE;
BEGIN
select employee_id,first_name,last_name
into e_id,e_fn,e_ln
from hr.employees
where employee_id = 100;
dbms_output.put_line(e_fn || ' ' || e_ln);
END;

if (salary >= 5000) then
dbms_output.put_line('salary suff');
end if;


begin
for i in 1..6 LOOP
dbms_output.put_line(i);
END LOOP;
END;

create or replace view emp_det as
select e.employee_id , e.first_name , d.department_name
from hr.employees e
join hr.departments d
on e.department_id = d.department_id;


create materialized view mat_emp_det as
select employee_id,first_name
from hr.employees
where department_id = 80;

select * from emp_det;

select*from mat_emp_det;

select*from hr.employees where department_id = 80;


CREATE OR REPLACE FUNCTION CalculateSAL
(DEPT_ID IN NUMBER)
RETURN NUMBER
IS
   Total_Salary NUMBER;
BEGIN
   SELECT SUM(Salary)
   INTO Total_Salary
   FROM employees
   WHERE department_id = DEPT_ID;

   RETURN Total_Salary;
END;
/
SELECT CalculateSAL(80) FROM dual;


create or replace trigger emp_insert_trg
after insert
on hr.employees
for each row
begin dbms_output.put_line('emp add: ' || :NEW.first_name);
END;
/

select * from hr.employees;

insert into hr.employees(employee_id,first_name,last_name,email,hire_date,department_id,job_id)  values(1,'ali','raza','aliraza@gmail.com','10-JUN-2021',80,1);

create or replace trigger emp_sal_update
before update of salary
on hr.employees
for each row
begin
dbms_output.put_line('salary changed: ' || :OLD.salary || 'to' || :NEW.salary);
END;


update hr.employees set salary = 6700
where employee_id = 100;


create or replace trigger check_salary
before update or insert 
on hr.employees
for each row
begin
if :NEW.salary < 0 then
RAISE_APPLICATION_ERROR(-2001,'salary cant be negative');
END IF;
END;

update hr.employees set salary = 6000
where employee_id = 100;

SET SERVEROUTPUT ON;
UPDATE hr.employees
SET salary =-2
WHERE employee_id = 100;


rollback

select* from hr.employees

--on
SET SERVEROUTPUT ON;
--print
DBMS_OUTPUT.PUT_LINE('text');
--block
DECLARE
BEGIN
END;
/
-- loop
FOR i IN 1..10 LOOP
END LOOP;
-- if
IF condition THEN
ELSIF condition THEN
ELSE
END IF;
-- select
SELECT col INTO variable FROM table WHERE condition;
-- func
CREATE OR REPLACE FUNCTION fname RETURN datatype
-- proc
CREATE OR REPLACE PROCEDURE pname IS
-- trigger
CREATE OR REPLACE TRIGGER tname
BEFORE/AFTER INSERT/UPDATE/DELETE
ON table
FOR EACH ROW


create or replace trigger check_available_seats
before update of available_seats
on courses
for each row
begin
if :NEW.available_seats < 3
then insert into course_alert(course_id,curr_seats,alert_msg,alert_date) values 
(:NEW.course_id,:NEW.available_seats,'low seats',sysdate);
end if;
end;
/

BEGIN

   INSERT INTO students VALUES (1,'Ali','ali@email.com');

   INSERT INTO enrollments VALUES (101,1,2,SYSDATE);

   UPDATE courses
   SET available_seats = available_seats - 1
   WHERE course_id = 2;

   INSERT INTO payments VALUES (201,101,SYSDATE,5000);

   INSERT INTO enrollment_log VALUES (301,101,'Enrollment completed');

   COMMIT;

EXCEPTION

   WHEN OTHERS THEN
      ROLLBACK;
      DBMS_OUTPUT.PUT_LINE('Transaction failed. Everything rolled back.');

END;
/


create or replace trigger stock_threshold_check
before update of stock_qunatity
on PRODUCTS
for each row
begin
if :NEW.stock_qunatity < 5
then 
insert into Stock_Alert(product_id,curr_stock,alert_msg,alertdate) values
(:NEW.product_id,:NEW.stock_qunatity,'low stock',sysdate);
end if;
end;
/

-- sequnce id generation
CREATE SEQUENCE stock_alert_seq
START WITH 1
INCREMENT BY 1;

-- use
stock_alert_seq.NEXTVAL;


-- transaction
SET SERVEROUTPUT ON;

BEGIN

   --------------------------------------------------
   -- STEP 1: INSERT NEW GUEST
   --------------------------------------------------
   INSERT INTO guests
   VALUES (1, 'Ali Khan', 'ali@gmail.com');

   --------------------------------------------------
   -- STEP 2: SELECT ROOM
   --------------------------------------------------
   -- Sample room assumed to exist (room_id = 101)
   --------------------------------------------------

   --------------------------------------------------
   -- STEP 3: MAKE RESERVATION
   --------------------------------------------------
   INSERT INTO reservations
   VALUES (1,  -- reservation_id
           1,  -- guest_id
           101, -- room_id
           SYSDATE,
           SYSDATE + 2);

   --------------------------------------------------
   -- STEP 4: PROCESS PAYMENT
   --------------------------------------------------
   INSERT INTO payments
   VALUES (1,
           1,   -- reservation_id
           15000);

   --------------------------------------------------
   -- STEP 5: LOG ACTION
   --------------------------------------------------
   INSERT INTO reservation_log
   VALUES (1,
           1,
           'Reservation created successfully');

   --------------------------------------------------
   -- STEP 6: COMMIT
   --------------------------------------------------
   COMMIT;

   DBMS_OUTPUT.PUT_LINE('Reservation transaction completed successfully.');

--------------------------------------------------
-- STEP 7: ROLLBACK ON FAILURE
--------------------------------------------------
EXCEPTION
   WHEN OTHERS THEN
      ROLLBACK;
      DBMS_OUTPUT.PUT_LINE('Transaction failed. All changes rolled back.');
END;
/


-- plsql
begin
create procedure RecordSale(
p_product_id in number,
p_sale_amount in number )
is v_count number;
v_stock number;
begin

select count(*)
into v_count
from products where product_id = p_prodcut_id;

if v_count = 0 then dbms_output.put_line('inn');
return;
end if;

select stock_qunatity
into v_stcok
from products where prod_id=p_prod_id;

if p_sale>v_stock then dbms_output.put_line('loe');
return;
end if;

 UPDATE products
   SET stock_quantity = stock_quantity - p_sale_amount
   WHERE product_id = p_product_id;

   INSERT INTO sales
   VALUES (sales_seq.NEXTVAL,
           p_product_id,
           SYSDATE,
           p_sale_amount);

   COMMIT;

   DBMS_OUTPUT.PUT_LINE('Sale recorded successfully.');

EXCEPTION
   WHEN OTHERS THEN
      ROLLBACK;
      DBMS_OUTPUT.PUT_LINE('Error occurred. Transaction rolled back.');
END;
/

-- func
CREATE OR REPLACE FUNCTION GetTotalSalesAmount
(
   p_product_id IN NUMBER
)
RETURN NUMBER
IS
   v_total_sales NUMBER;
BEGIN

   SELECT NVL(SUM(sale_amount),0)
   INTO v_total_sales
   FROM sales
   WHERE product_id = p_product_id;

   RETURN v_total_sales;

END;
/
